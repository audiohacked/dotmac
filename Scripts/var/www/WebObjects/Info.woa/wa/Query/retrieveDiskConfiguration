#!/usr/bin/perl -w
## Copyright (C) 2007 Walinsky
## This program is free software; you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by the 
## Free Software Foundation; either version 2 of the License, or (at your option)
## any later version.

use HTTP::DAV;

# Grab the username and password from the input data.
# Perl puts the results from a REGEX into $1
while(<STDIN>){
 if ( /username\s+=\s+(.*?)\;/ ){
   $username = $1;
 }

 if ( /password\s+=\s+(.*?)\;/ ){
   $password = $1;
 }
}

# Initialize the quota and quotaused variables to 0
my $quota = 0;
my $quotaused = 0;

# Create a new instance of Dav. This requires 
$webdav_client = new HTTP::DAV;

# Initialize the url to POST the webdav request.
$webdavserver_url = "http://idisk.walinsky.com:80/$username/";

# Establish the webdav credentials
# don't hardcode the realm in the credentials  -realm=>"idisk.mac.com"
$webdav_client->credentials( -user=>"$username", -pass =>"$password", 
				-url =>$webdavserver_url );
				
# Have the webdav client open the url with the user's credentials or die with an error message
$webdav_client->open( -url=>"$webdavserver_url") or die("Couldn't open $webdavserver_url: " .$webdav_client->message . "\n");

# Dive straight into HTTP::DAV::Resource.pm as HTTP::DAV won't let us make specific propfind requests (just allprop)
$resource = $webdav_client->get_workingresource();

# Let's query for 'quota' and 'quotaused'
$resource->propfind( 
             -depth => 0, 
             -text  => "<D:prop><D:quota/><D:quotaused/></D:prop>");

# Get the properities (in kilobytes) from propfind request made to the webdav server
$quota = $resource->get_property("quota");
$quotaused = $resource->get_property("quotaused");


# Disconnect the client from the webdav server.
$webdav_client->unlock( -url => $webdavserver_url );

# Change the quota and quotaused from kilobytes (KB) to bytes (B)
$quota *= 512;
$quotaused *= 512;

# Send the response back to the .mac client requesting the information
print <<EOCONF
Content-type: text/plain

{
    payload = {
        guestReadEnabled = Y;
        guestWriteEnabled = N;
        hasGeneralPassword = N;
        iDiskQuotaInBytes = $quota;
        iDiskUsedBytes = $quotaused;
        relativePath = Public;
    };
    statusCode = success;
}
EOCONF
;
# TODO: find where the buttons guest read/write point to; and gather the info in this script
